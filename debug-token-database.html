<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eTax Mobile - Database Debug Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .debug-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #007bff;
        }
        
        .debug-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .debug-content {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }
        
        .form-group {
            margin: 20px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }
        
        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: monospace;
            text-transform: uppercase;
        }
        
        .btn {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn-success { background: linear-gradient(45deg, #28a745, #1e7e34); }
        .btn-warning { background: linear-gradient(45deg, #ffc107, #e0a800); }
        .btn-danger { background: linear-gradient(45deg, #dc3545, #c82333); }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .status-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .status-card.error { border-left-color: #dc3545; }
        .status-card.warning { border-left-color: #ffc107; }
        
        .highlight {
            background: yellow;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß eTax Mobile - Database Debug Tool</h1>
            <p>Ph√°t hi·ªán v√† s·ª≠a l·ªói token verification</p>
        </div>

        <div class="form-group">
            <label for="tokenInput">Nh·∫≠p token c·∫ßn debug:</label>
            <input type="text" id="tokenInput" placeholder="VD: ETAXMCS177CA6W0V0" value="ETAXMCS177CA6W0V0">
        </div>

        <div class="form-group">
            <button class="btn" onclick="debugToken()">üîç Debug Token</button>
            <button class="btn btn-success" onclick="checkDatabaseStructure()">üóÑÔ∏è Ki·ªÉm tra Database</button>
            <button class="btn btn-warning" onclick="fixTokenStructure()">üîß S·ª≠a Token Structure</button>
            <button class="btn btn-danger" onclick="testTokenVerification()">‚úÖ Test Verification</button>
        </div>

        <div id="errorMsg" class="message error"></div>
        <div id="successMsg" class="message success"></div>
        <div id="infoMsg" class="message info"></div>

        <div class="status-grid">
            <div class="status-card" id="dbConnectionStatus">
                <h4>üîó Database Connection</h4>
                <p id="dbStatus">ƒêang ki·ªÉm tra...</p>
            </div>
            <div class="status-card" id="tokenFoundStatus">
                <h4>üé´ Token T√¨m Th·∫•y</h4>
                <p id="tokenStatus">Ch∆∞a test</p>
            </div>
            <div class="status-card" id="userFoundStatus">
                <h4>üë§ User Li√™n K·∫øt</h4>
                <p id="userStatus">Ch∆∞a test</p>
            </div>
            <div class="status-card" id="structureStatus">
                <h4>üìã C·∫•u Tr√∫c</h4>
                <p id="structStatus">Ch∆∞a ki·ªÉm tra</p>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-title">üîç Token Debug Results</div>
            <div class="debug-content" id="tokenDebugResults">Nh·∫•n "Debug Token" ƒë·ªÉ b·∫Øt ƒë·∫ßu...</div>
        </div>

        <div class="debug-section">
            <div class="debug-title">üóÑÔ∏è Database Structure</div>
            <div class="debug-content" id="dbStructureResults">Nh·∫•n "Ki·ªÉm tra Database" ƒë·ªÉ xem c·∫•u tr√∫c...</div>
        </div>

        <div class="debug-section">
            <div class="debug-title">üîß Fix Suggestions</div>
            <div class="debug-content" id="fixSuggestions">Ch·∫°y debug ƒë·ªÉ xem g·ª£i √Ω s·ª≠a l·ªói...</div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyD_rJgBFgBulheVenQUE2KXr4PBpSpTCxw",
            authDomain: "etax-7fbf8.firebaseapp.com",
            databaseURL: "https://etax-7fbf8-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "etax-7fbf8",
            storageBucket: "etax-7fbf8.appspot.com",
            messagingSenderId: "1030026724634",
            appId: "1:1030026724634:web:d76f5f9dad43bad6fd58a3",
            measurementId: "G-YS5DLECJE6"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let debugResults = {};

        // Ki·ªÉm tra k·∫øt n·ªëi database
        async function checkDatabaseConnection() {
            try {
                await db.ref('.info/connected').once('value');
                updateStatus('dbConnectionStatus', 'success', '‚úÖ K·∫øt n·ªëi th√†nh c√¥ng');
                return true;
            } catch (error) {
                updateStatus('dbConnectionStatus', 'error', '‚ùå L·ªói k·∫øt n·ªëi: ' + error.message);
                return false;
            }
        }

        // Debug token c·ª• th·ªÉ
        async function debugToken() {
            const token = document.getElementById('tokenInput').value.trim();
            if (!token) {
                showError('Vui l√≤ng nh·∫≠p token c·∫ßn debug');
                return;
            }

            showInfo('üîç ƒêang debug token: ' + token);
            debugResults = { token, searches: [], conclusions: [] };

            // Ki·ªÉm tra k·∫øt n·ªëi
            if (!(await checkDatabaseConnection())) return;

            try {
                // T√¨m token ·ªü c√°c v·ªã tr√≠ c√≥ th·ªÉ
                const searchLocations = [
                    'deviceTokens/' + token,
                    'tokens/' + token,
                    'userTokens/' + token,
                    'device_tokens/' + token
                ];

                for (let location of searchLocations) {
                    try {
                        console.log(`üîç Searching in: ${location}`);
                        const snapshot = await db.ref(location).once('value');
                        
                        const result = {
                            location,
                            exists: snapshot.exists(),
                            data: snapshot.exists() ? snapshot.val() : null
                        };

                        debugResults.searches.push(result);

                        if (snapshot.exists()) {
                            updateStatus('tokenFoundStatus', 'success', `‚úÖ T√¨m th·∫•y t·∫°i: ${location}`);
                            showSuccess(`‚úÖ Token t√¨m th·∫•y t·∫°i: ${location}`);
                            
                            // Ph√¢n t√≠ch c·∫•u tr√∫c token
                            await analyzeTokenStructure(snapshot.val(), location);
                        }
                    } catch (error) {
                        debugResults.searches.push({
                            location,
                            error: error.message
                        });
                    }
                }

                // T√¨m ki·∫øm to√†n b·ªô database n·∫øu kh√¥ng t√¨m th·∫•y
                if (debugResults.searches.filter(s => s.exists).length === 0) {
                    await searchEntireDatabase(token);
                }

                // Hi·ªÉn th·ªã k·∫øt qu·∫£
                displayDebugResults();

            } catch (error) {
                showError('L·ªói debug: ' + error.message);
                console.error('Debug error:', error);
            }
        }

        // Ph√¢n t√≠ch c·∫•u tr√∫c token
        async function analyzeTokenStructure(tokenData, location) {
            console.log('üìã Analyzing token structure:', tokenData);
            
            const analysis = {
                location,
                structure: {},
                issues: [],
                suggestions: []
            };

            // Ki·ªÉm tra c√°c field quan tr·ªçng
            const requiredFields = ['userId', 'status', 'createdAt', 'expiresAt'];
            const optionalFields = ['used', 'valid', 'expires_at', 'uid'];

            for (let field of requiredFields) {
                if (tokenData.hasOwnProperty(field)) {
                    analysis.structure[field] = { exists: true, value: tokenData[field] };
                } else {
                    analysis.structure[field] = { exists: false };
                    analysis.issues.push(`Missing required field: ${field}`);
                }
            }

            for (let field of optionalFields) {
                if (tokenData.hasOwnProperty(field)) {
                    analysis.structure[field] = { exists: true, value: tokenData[field] };
                }
            }

            // Ki·ªÉm tra status field
            if (tokenData.status) {
                if (!['active', 'used', 'expired'].includes(tokenData.status)) {
                    analysis.issues.push(`Invalid status value: ${tokenData.status}`);
                }
            } else if (tokenData.valid !== undefined) {
                analysis.suggestions.push('Convert "valid" field to "status" field');
            }

            // Ki·ªÉm tra userId/uid
            if (tokenData.userId) {
                await checkUserExists(tokenData.userId);
            } else if (tokenData.uid) {
                await checkUserExists(tokenData.uid);
                analysis.suggestions.push('Convert "uid" to "userId"');
            } else {
                analysis.issues.push('No user reference found');
                updateStatus('userFoundStatus', 'error', '‚ùå Kh√¥ng c√≥ user li√™n k·∫øt');
            }

            debugResults.tokenAnalysis = analysis;
        }

        // Ki·ªÉm tra user t·ªìn t·∫°i
        async function checkUserExists(userId) {
            try {
                const userSnapshot = await db.ref('users/' + userId).once('value');
                if (userSnapshot.exists()) {
                    updateStatus('userFoundStatus', 'success', '‚úÖ User t·ªìn t·∫°i: ' + userId);
                    debugResults.userFound = { exists: true, userId, data: userSnapshot.val() };
                } else {
                    updateStatus('userFoundStatus', 'error', '‚ùå User kh√¥ng t·ªìn t·∫°i: ' + userId);
                    debugResults.userFound = { exists: false, userId };
                }
            } catch (error) {
                updateStatus('userFoundStatus', 'error', '‚ùå L·ªói ki·ªÉm tra user: ' + error.message);
            }
        }

        // T√¨m ki·∫øm to√†n b·ªô database
        async function searchEntireDatabase(token) {
            showInfo('üîç T√¨m ki·∫øm to√†n b·ªô database...');
            
            try {
                // L·∫•y to√†n b·ªô database (ch·ªâ level ƒë·∫ßu)
                const snapshot = await db.ref('/').once('value');
                const data = snapshot.val();
                
                const foundLocations = [];
                
                // T√¨m token trong t·∫•t c·∫£ c√°c node
                function searchInObject(obj, path = '') {
                    if (typeof obj === 'object' && obj !== null) {
                        for (let key in obj) {
                            const currentPath = path ? `${path}/${key}` : key;
                            
                            if (key === token) {
                                foundLocations.push(currentPath);
                            } else if (typeof obj[key] === 'object') {
                                searchInObject(obj[key], currentPath);
                            }
                        }
                    }
                }
                
                searchInObject(data);
                
                debugResults.fullSearch = {
                    performed: true,
                    foundLocations
                };
                
                if (foundLocations.length > 0) {
                    showSuccess(`üéØ Token t√¨m th·∫•y t·∫°i: ${foundLocations.join(', ')}`);
                    updateStatus('tokenFoundStatus', 'success', `‚úÖ T√¨m th·∫•y ${foundLocations.length} v·ªã tr√≠`);
                } else {
                    showError('‚ùå Token kh√¥ng t·ªìn t·∫°i trong database');
                    updateStatus('tokenFoundStatus', 'error', '‚ùå Token kh√¥ng t·ªìn t·∫°i');
                }
                
            } catch (error) {
                showError('L·ªói t√¨m ki·∫øm database: ' + error.message);
            }
        }

        // Ki·ªÉm tra c·∫•u tr√∫c database
        async function checkDatabaseStructure() {
            showInfo('üóÑÔ∏è ƒêang ki·ªÉm tra c·∫•u tr√∫c database...');
            
            try {
                const structure = {};
                const mainNodes = ['users', 'tokens', 'deviceTokens', 'device_tokens', 'userTokens'];
                
                for (let node of mainNodes) {
                    try {
                        const snapshot = await db.ref(node).once('value');
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            const keys = Object.keys(data);
                            
                            structure[node] = {
                                exists: true,
                                count: keys.length,
                                sampleKeys: keys.slice(0, 3),
                                sampleData: data[keys[0]] || null
                            };
                        } else {
                            structure[node] = { exists: false };
                        }
                    } catch (error) {
                        structure[node] = { error: error.message };
                    }
                }
                
                document.getElementById('dbStructureResults').textContent = JSON.stringify(structure, null, 2);
                updateStatus('structureStatus', 'success', '‚úÖ ƒê√£ ki·ªÉm tra c·∫•u tr√∫c');
                showSuccess('‚úÖ ƒê√£ ki·ªÉm tra c·∫•u tr√∫c database');
                
            } catch (error) {
                showError('L·ªói ki·ªÉm tra c·∫•u tr√∫c: ' + error.message);
            }
        }

        // S·ª≠a c·∫•u tr√∫c token
        async function fixTokenStructure() {
            const token = document.getElementById('tokenInput').value.trim();
            if (!token) {
                showError('Vui l√≤ng nh·∫≠p token c·∫ßn s·ª≠a');
                return;
            }

            showInfo('üîß ƒêang s·ª≠a c·∫•u tr√∫c token...');
            
            // Th·ª±c hi·ªán debug tr∆∞·ªõc
            await debugToken();
            
            if (!debugResults.tokenAnalysis) {
                showError('Kh√¥ng t√¨m th·∫•y token ƒë·ªÉ s·ª≠a');
                return;
            }

            try {
                const analysis = debugResults.tokenAnalysis;
                const currentData = debugResults.searches.find(s => s.exists)?.data;
                
                if (!currentData) {
                    showError('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu token');
                    return;
                }

                // T·∫°o c·∫•u tr√∫c m·ªõi chu·∫©n
                const fixedData = {
                    userId: currentData.userId || currentData.uid,
                    status: currentData.status || (currentData.valid ? 'active' : 'used'),
                    createdAt: currentData.createdAt || currentData.created_at || Date.now(),
                    expiresAt: currentData.expiresAt || currentData.expires_at,
                    token: token,
                    deviceId: currentData.deviceId || null,
                    usedAt: currentData.usedAt || null
                };

                // L∆∞u v√†o v·ªã tr√≠ chu·∫©n
                await db.ref('deviceTokens/' + token).set(fixedData);
                
                showSuccess('‚úÖ ƒê√£ s·ª≠a c·∫•u tr√∫c token th√†nh c√¥ng!');
                
                // Test l·∫°i
                setTimeout(() => testTokenVerification(), 1000);
                
            } catch (error) {
                showError('L·ªói s·ª≠a token: ' + error.message);
            }
        }

        // Test token verification
        async function testTokenVerification() {
            const token = document.getElementById('tokenInput').value.trim();
            if (!token) {
                showError('Vui l√≤ng nh·∫≠p token c·∫ßn test');
                return;
            }

            showInfo('‚úÖ ƒêang test token verification...');
            
            try {
                // Th·ª±c hi·ªán logic gi·ªëng token-login.html
                const tokenSnapshot = await db.ref('deviceTokens/' + token).once('value');
                
                if (!tokenSnapshot.exists()) {
                    showError('‚ùå Token kh√¥ng t·ªìn t·∫°i');
                    return;
                }

                const tokenData = tokenSnapshot.val();
                const results = {
                    tokenExists: true,
                    tokenData,
                    checks: {}
                };

                // Check expiration
                if (tokenData.expiresAt && Date.now() > tokenData.expiresAt) {
                    results.checks.expiration = { passed: false, message: 'Token ƒë√£ h·∫øt h·∫°n' };
                } else {
                    results.checks.expiration = { passed: true, message: 'Token c√≤n h·∫°n' };
                }

                // Check status
                if (tokenData.status !== 'active') {
                    results.checks.status = { passed: false, message: `Status: ${tokenData.status}` };
                } else {
                    results.checks.status = { passed: true, message: 'Status: active' };
                }

                // Check user
                const userSnapshot = await db.ref('users/' + tokenData.userId).once('value');
                if (!userSnapshot.exists()) {
                    results.checks.user = { passed: false, message: 'User kh√¥ng t·ªìn t·∫°i' };
                } else {
                    results.checks.user = { passed: true, message: 'User t·ªìn t·∫°i', userData: userSnapshot.val() };
                }

                results.overallResult = Object.values(results.checks).every(check => check.passed);

                // Hi·ªÉn th·ªã k·∫øt qu·∫£
                const resultText = `
VERIFICATION TEST RESULTS:
=========================
Token: ${token}
Overall Result: ${results.overallResult ? '‚úÖ PASS' : '‚ùå FAIL'}

Detailed Checks:
${Object.entries(results.checks).map(([key, check]) => 
    `- ${key}: ${check.passed ? '‚úÖ' : '‚ùå'} ${check.message}`
).join('\n')}

Token Data:
${JSON.stringify(tokenData, null, 2)}
                `;

                document.getElementById('tokenDebugResults').textContent = resultText;

                if (results.overallResult) {
                    showSuccess('üéâ Token verification test PASSED!');
                } else {
                    showError('‚ùå Token verification test FAILED!');
                }

            } catch (error) {
                showError('L·ªói test verification: ' + error.message);
            }
        }

        // Hi·ªÉn th·ªã k·∫øt qu·∫£ debug
        function displayDebugResults() {
            const results = `
DEBUG RESULTS FOR TOKEN: ${debugResults.token}
=============================================

Search Results:
${debugResults.searches.map(search => `
- Location: ${search.location}
- Exists: ${search.exists}
- Data: ${search.data ? JSON.stringify(search.data, null, 2) : 'null'}
- Error: ${search.error || 'none'}
`).join('\n')}

${debugResults.tokenAnalysis ? `
Token Analysis:
- Location: ${debugResults.tokenAnalysis.location}
- Issues: ${debugResults.tokenAnalysis.issues.join(', ') || 'none'}
- Suggestions: ${debugResults.tokenAnalysis.suggestions.join(', ') || 'none'}
- Structure: ${JSON.stringify(debugResults.tokenAnalysis.structure, null, 2)}
` : ''}

${debugResults.userFound ? `
User Check:
- Exists: ${debugResults.userFound.exists}
- User ID: ${debugResults.userFound.userId}
- Data: ${debugResults.userFound.data ? JSON.stringify(debugResults.userFound.data, null, 2) : 'null'}
` : ''}

${debugResults.fullSearch ? `
Full Database Search:
- Found Locations: ${debugResults.fullSearch.foundLocations.join(', ') || 'none'}
` : ''}
            `;

            document.getElementById('tokenDebugResults').textContent = results;

            // T·∫°o g·ª£i √Ω s·ª≠a l·ªói
            generateFixSuggestions();
        }

        // T·∫°o g·ª£i √Ω s·ª≠a l·ªói
        function generateFixSuggestions() {
            const suggestions = [];

            if (debugResults.searches.filter(s => s.exists).length === 0) {
                suggestions.push('‚ùå TOKEN KH√îNG T·ªíN T·∫†I - C·∫ßn t·∫°o token m·ªõi trong Admin Panel');
            } else {
                const foundToken = debugResults.searches.find(s => s.exists);
                const tokenData = foundToken.data;

                if (!tokenData.userId && !tokenData.uid) {
                    suggestions.push('üîß Thi·∫øu user reference - C·∫ßn th√™m userId');
                }

                if (!tokenData.status) {
                    if (tokenData.valid !== undefined) {
                        suggestions.push('üîß Convert "valid" field th√†nh "status" field');
                    } else {
                        suggestions.push('üîß Thi·∫øu status field - C·∫ßn th√™m status: "active"');
                    }
                }

                if (tokenData.expires_at && !tokenData.expiresAt) {
                    suggestions.push('üîß Convert "expires_at" th√†nh "expiresAt"');
                }

                if (debugResults.userFound && !debugResults.userFound.exists) {
                    suggestions.push('‚ùå User kh√¥ng t·ªìn t·∫°i - C·∫ßn t·∫°o user ho·∫∑c fix userId');
                }

                if (foundToken.location !== 'deviceTokens/' + debugResults.token) {
                    suggestions.push('üîß Token kh√¥ng ·ªü ƒë√∫ng location chu·∫©n - C·∫ßn move v·ªÅ deviceTokens');
                }
            }

            if (suggestions.length === 0) {
                suggestions.push('‚úÖ Token structure looks good! C√≥ th·ªÉ c√≥ v·∫•n ƒë·ªÅ kh√°c.');
            }

            const suggestionText = `
FIX SUGGESTIONS:
================
${suggestions.join('\n')}

RECOMMENDED ACTIONS:
====================
1. Nh·∫•n "üîß S·ª≠a Token Structure" ƒë·ªÉ auto-fix
2. Nh·∫•n "‚úÖ Test Verification" ƒë·ªÉ ki·ªÉm tra
3. N·∫øu v·∫´n l·ªói, t·∫°o token m·ªõi trong Admin Panel
            `;

            document.getElementById('fixSuggestions').textContent = suggestionText;
        }

        // Helper functions
        function updateStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            const status = element.querySelector('p');
            status.textContent = message;
            
            element.className = 'status-card';
            if (type === 'success') element.classList.add('success');
            if (type === 'error') element.classList.add('error');
            if (type === 'warning') element.classList.add('warning');
        }

        function showError(message) {
            hideMessages();
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            console.error(message);
        }

        function showSuccess(message) {
            hideMessages();
            const successMsg = document.getElementById('successMsg');
            successMsg.textContent = message;
            successMsg.style.display = 'block';
            console.log(message);
        }

        function showInfo(message) {
            hideMessages();
            const infoMsg = document.getElementById('infoMsg');
            infoMsg.textContent = message;
            infoMsg.style.display = 'block';
            console.info(message);
        }

        function hideMessages() {
            document.getElementById('errorMsg').style.display = 'none';
            document.getElementById('successMsg').style.display = 'none';
            document.getElementById('infoMsg').style.display = 'none';
        }

        // Kh·ªüi t·∫°o
        window.addEventListener('load', async () => {
            console.log('üöÄ Debug Tool loaded successfully');
            await checkDatabaseConnection();
            showInfo('üí° Nh·∫≠p token v√† nh·∫•n "Debug Token" ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch');
        });

        // Auto debug khi nh·∫≠p token
        document.getElementById('tokenInput').addEventListener('input', function(e) {
            e.target.value = e.target.value.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
        });

        // Enter key trigger
        document.getElementById('tokenInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                debugToken();
            }
        });

        console.log('üîß eTax Mobile Debug Tool initialized');
    </script>
</body>
</html>